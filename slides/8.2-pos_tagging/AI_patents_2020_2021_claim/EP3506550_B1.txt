<document>

<filing_date>
2019-01-02
</filing_date>

<publication_date>
2020-09-23
</publication_date>

<priority_date>
2017-12-28
</priority_date>

<ipc_classes>
H04L9/00,H04L9/08
</ipc_classes>

<assignee>
FLYTXT
</assignee>

<inventors>
VEUGEN, THIJS
</inventors>

<docdb_family_id>
60971937
</docdb_family_id>

<title>
PROVIDING SECURITY AGAINST USER COLLUSION IN DATA ANALYTICS USING RANDOM GROUP SELECTION
</title>

<abstract>
Methods for secure random selection of t client devices which from a set of N client devices and methods for secure computation of inputs of t client devices which are randomly selected from a set of N client devices are described. Such random selection method may include determining an initial binary vector b of weight t by setting the first t bits to one: bi = 1, 1 ≤ i ≤ t, and all further bits to zero: bi = 0, t < i ≤ N; each client device i (i=1,...,N) of the set of N client devices jointly generating a random binary vector b of weight t in an obfuscated domain on the basis of the initial binary vector b including: determining a position n in the binary vector; determining a random number r in {n,n+1,...N}; and, using the random number to swap binary values at positions n and r of the binary vector b.
</abstract>

<claims>
1. A method for secure computation of inputs of t client devices (204) which are randomly selected from a set of N client devices (202), the method comprising: each client device i (i=1,...,N)(102) of the set of N client devices generating a random binary vector b of weight t in an obfuscated domain, preferably the obfuscated domain being an encrypted domain or a secret-sharing domain, each client device i transforming an input value xi into the obfuscated domain and determining the product bi · xi of bit value bi at position i of the random binary vector and the input value xi in the obfuscated domain; and, performing a secure computation in the obfuscated domain on the basis of the products bi · xi (i=1,...,N); the generating of the random binary vector b of weight t in the obfuscated domain by each of the client devices including: - determining an initial binary vector of weight t by setting the first t bits to one: bi = 1, 1 ≤ i ≤ t, and all further bits to zero: bi = 0, t < i ≤ N; - generating the random binary vector b based on the initial binary vector, the generating including for each position n (1 ≤ n ≤ t) in the binary vector jointly determining a random number r in the range {n,n+1,...N}; and, using the random number r for swapping a binary value at position n with a binary value at position r of the binary vector b.
2. Method according to claim 1 wherein a delta function δin, preferably an obfuscated delta function, is used for swapping the bit values in the obfuscated domain, wherein δin = 1, if a random value rn is equal to position i binary vector, and δin = 0, for all other i positions in the binary vector, preferably the delta function δin being defined based on a polynomial function Din(x): wherein dj represent coefficients of the Lagrange polynomial Din(x).
3. Method according to claims 1 or 2 wherein the obfuscated domain is based on a homomorphic cryptosystem, preferably an additive homomorphic cryptosystem; and, optionally, an encrypted delta function is used for swapping the bit values, the encrypted delta function being defined by the expression: wherein dj, 0 ≤ j ≤ N - n, represent the Lagrange coefficients of the Lagrange polynomial Din(x).
4. Method according to claim 3 wherein the random generated binary vector includes encrypted random bits [bi], 1 ≤ i ≤ N, such that Σibi = t; wherein the client device i processes its input xi on the basis of the binary vector of encrypted bits by computing [xi ·bi] = [bi]xi; and, wherein the secure computation in the obfuscated domain is based on the computed values [xi ·bi] (i=1,...,N).
5. The method according to claim 4 further including: each of the client devices i transmitting the computed value [xi ·bi] to a server, preferably an aggregation server; and, the server performing the secure computation on the basis of the computed values [xi ·bi] (i=1,...,N).
6. The method according to claim 4 further including: each of the client devices transmitting the computed value [xi ·bi] to one or more client devices; and, the one or more client devices performing the secure computation on the basis of [xi ·bi] (i=1,...,N).
7. Method according to claim 1 wherein the obfuscated domain is based on a secret-sharing system, preferably the secret-sharing system being based on a modulo computation using a fixed prime p. and, optionally, and, optionally, a secret shared delta function is used for swapping the bit values, the secret shared delta function being defined by the expression: wherein dj, 0 ≤ j ≤ N - n, represent the Lagrange coefficients of the Lagrange polynomial Din(x).
8. Method according to claim 7 wherein the random generated binary vector includes secretly-shared random bits 〈bi〉, 1 ≤ i ≤ N, such that Σi bi = t; wherein the client device i determines a secret sharing 〈xi〉 using the fixed prime p, and uses 〈xi〉 to compute 〈xi ·bi〉; and wherein the secure computation in the obfuscated domain is based on the computed values 〈bi · xi〉 (i=1,N).
9. A system for secure computation of inputs of t client devices (204) which are randomly selected from a set of N client devices (202) comprising:
a set of client devices i (i=1,...,N), each client device (102) comprising a computer readable storage medium having computer readable program code embodied therewith, the program code including an obfuscation function, preferably a homomorphic encryption function or a secret-sharing function, for performing computations in an obfuscated domain and a processor, preferably a microprocessor, coupled to the computer readable storage medium, wherein responsive to executing the first computer readable program code, wherein the processor is configured to perform executable operations comprising: generating a random binary vector b of weight t in an obfuscated domain, preferably an encrypted domain or a secret-sharing domain; transforming an input value xi into the obfuscated domain, and determining the product bi · xi of bit value bi at position i of the random binary vector, and the input value xi in the obfuscated domain; and, transmitting the computed product bi · xi to a server system (112) or to a further client device (102), wherein the server or the further client device is configured to perform a secure computation in the obfuscated domain on the basis of the products bi · xi (i=1,...,N)computed by each client device i (1=1,...,N); wherein the generating of the random binary vector b of weight t in the obfuscated domain includes: - determining an initial binary vector of weight t by setting the first t bits to one: bi = 1, 1 ≤ i ≤ t, and all further bits to zero: bi = 0, t < i ≤ N; - generating the random binary vector b based on the initial binary vector, the generating including for each position n (1 ≤ n ≤ t) in the binary vector jointly determining a random number r in the range {n,n+1,...N}; and, using the random number r for swapping a binary value at position n with a binary value at position r of the binary vector b.
10. A client apparatus for use in a system for secure computation of inputs of t client devices which are randomly selected from a set of N client devices, preferably a system according to claim 10, comprising:
a computer readable storage medium having computer readable program code embodied therewith, the program code including an obfuscation function, preferably a homomorphic encryption function or a secret-sharing function, for performing computations in an obfuscated domain and a processor, preferably a microprocessor, coupled to the computer readable storage medium, wherein responsive to executing the first computer readable program code, wherein the processor is configured to perform executable operations comprising: generating a random binary vector b of weight t in the obfuscated domain; transforming an input value xi into the obfuscated domain and determining the product bi · xi of bit value bi at position i of the random binary vector and the input value xi in the obfuscated domain; and, optionally, transmitting the computed product bi · xi to a server system or to a further client device, wherein the server or the further client device is configured to perform a secure computation in the obfuscated domain on the basis of the products bi · xi (i=1,...,N) computed by each client device i (i=1,...,N); wherein the generating of the random binary vector b of weight t in the obfuscated domain includes: - determining an initial binary vector of weight t by setting the first t bits to one: bi = 1, 1 ≤ i ≤ t, and all further bits to zero: bi = 0, t < i ≤ N; - generating the random binary vector b based on the initial binary vector, the generating including for each position n (1 ≤ n ≤ t) in the binary vector jointly determining a random number r in the range {n,n+1,...N}; and, using the random number r for swapping a binary value at position n with a binary value at position r of the binary vector b.
11. A method for secure random selection of t client devices (204) from a set of N client devices (202) comprising: determining an initial binary vector b of weight t by setting the first t bits to one: bi = 1, 1 ≤ i ≤ t, and all further bits to zero: bi = 0, t < i ≤ N; each client device i (i=1,...,N) (102) of the set of N client devices generating a random binary vector b of weight t in an obfuscated domain based on the initial binary vector b, wherein bit value bi at position i in the random binary vector b signals if client device i is selected or not, the generation of the random binary vector including for each position n (1 ≤ n ≤ t) in the binary vector b: - each of the client devices jointly a random number r in the range {n,n+1,...N}; and, - using the random number r to swap binary values at position n and position r of the binary vector b.
12. Method according to claim 11 wherein the swapping of the binary values at positions n and r is based on a delta function δin, preferably an obfuscated delta function, wherein δin = 1, if a random value rn = i, and δin = 0, for all other i positions in the random binary vector, preferably the delta function δin being defined on the basis of a polynomial function Din(x): wherein dj represent coefficients of the Lagrange polynomial Din(x), more preferably the obfuscated delta function being an encrypted delta function defined by the expression: or a secret shared delta function defined by the expression: wherein dj, 0 ≤ j ≤ N - n, represent the Lagrange coefficients of the Lagrange polynomial Din(x).
13. Method according to claims 11 or 12 wherein the obfuscated domain is based on a homomorphic cryptosystem, preferably an additive homomorphic cryptosystem and wherein determining a random number r further includes: each client device i generating l random bits, 0 ≤ j < l, where l is such that 2l -1 ≤ N - n < 2l, encrypting the random bits αij using the homomorphic cryptosystem; each client device i computing 1 encrypted random bits [αj], 0 ≤ j < 1, wherein [αj]=[α1j] ⊕ α2j ⊕ ... ⊕ αNj]); each client device i computing an encrypted random number [r] on the basis of the encrypted random bits [αj], preferably the computing including and determining if the encrypted random number is smaller than or equal to N - n.
14. Method according to claims 11 or 12 wherein the obfuscated domain is based on a secret-sharing system, preferably the secret-sharing system being based on a modulo computation using a fixed prime p; and wherein determining a random number r further includes: each client device i may generating l random bits αij , 0 ≤ j < l, where l is such that 2l-1 ≤ N - n < 2l, transforming the random bits to the secretly-shared domain; the client devices jointly compute l secretly-shared random bits 〈αj〉, 0 ≤ j < l wherein 〈αj〉 = 〈α1j ⊕ α2j ⊕ ... ⊕ αNj); each client device i computing the secretly shared random number 〈r〉 on the basis of the secretly shared random bits 〈αj〉, preferably the computing including and, determining if the secretly shared random number is smaller than or equal to N - n.
</claims>
</document>

<document>

<filing_date>
2019-06-25
</filing_date>

<publication_date>
2020-12-31
</publication_date>

<priority_date>
2019-06-25
</priority_date>

<ipc_classes>
G06F9/445,G06N20/00
</ipc_classes>

<assignee>
NXP USA
</assignee>

<inventors>
MATHUR ASHISH
Jain, Diviya
</inventors>

<docdb_family_id>
74042765
</docdb_family_id>

<title>
SELF-OPTIMIZING MULTI-CORE INTEGRATED CIRCUIT
</title>

<abstract>
A self-optimizing System-on-Chip (SOC) includes multiple cores, multiple hardware accelerators, multiple memories and an interconnect framework. The SOC also includes a machine learning (ML) module that uses data flow information to build a ML network dynamically and configures all the various hardware blocks autonomously, to achieve predetermined application performance targets. The SOC is able to recover from hangs caused when testing various configuration settings. The SOC also avoids configuration settings that cause severe drops in performance.
</abstract>

<claims>
1. A self-optimizing System on a Chip (SOC), comprising: multiple cores, multiple hardware accelerators, multiple memories, and an interconnection framework that couples the cores, the accelerators and the memories to permit programs to be executed by the SOC; a SOC reset controller configured to reset the SOC; a machine learning (ML) module in communication with the multiple cores, the multiple hardware accelerators, the interconnection framework, the multiple memories and the SOC reset controller that adjusts configuration parameters of the cores, the hardware accelerators, interconnect elements and the memories autonomously until a desired performance target is achieved, wherein the ML module adjusts the configuration parameters to meet the desired performance target by tuning the configuration parameters and autonomously cycling through configuration training sequences until the desired performance target is achieved; a pathological configuration list, generated by the ML module, comprising a list of configuration parameter settings that lead to severe performance drops, by classifying performance drops below a predetermined threshold value as pathological, wherein the ML module checks if new configuration parameters match a configuration setting in the pathological configuration list and if there is a match, then the ML module does not run the configuration training sequences using said configuration parameters and generates a next new configuration parameters.
2. The self-optimizing SOC of claim 1, wherein the ML module is configured to provide a protocol for synchronized updates of the configuration parameters to avoid undefined behaviors due to dynamic runtime configuration changes, wherein the protocol includes the ML module receiving confirmation of quiescent state before pushing new configuration parameters.
3. The self-optimizing SOC of claim 2, wherein the SOC reset controller includes a reset timer that causes the SoC reset controller to issue a reset of the SOC if the quiescent state is not attained within a predetermined quiescent time value.
4. The self-optimizing SOC of claim 1, further comprising: a debug module that generates compute flow information related to compute flows active in the SOC, and wherein the ML module fetches the compute flow information from the debug module using a ML_FLOW_INFO interface.
5. The self-optimizing SOC of claim 4, wherein the ML module includes a ML_SOC_PERF interface for communicating with the debug module to performance metrics related to the desired performance target and the current SoC state.
6. The self-optimizing SOC of claim 5, wherein the ML module uses the compute flow information and the performance metrics to build a ML Network dynamically.
7. The self-optimizing SOC of claim 1, wherein the configuration parameters include configuration space address, register offset, configuration parameter bit-field offset, parameter legal range, parameter change step size and parameter change condition.
8. The self-optimizing SOC of claim 1, wherein the ML module fetches the configuration parameters from one of the memories and saves the fetched configuration parameters in an internal memory of the ML module for fast access thereto.
9. The self-optimizing SOC of claim 1, wherein the ML module includes a ML_SEQ interface that includes ML_FREEZE signals that are asserted by the ML module in an order specified by a data flow to the cores and the accelerators to request the cores and the accelerators to discontinue processing of new data.
10. The self-optimizing SOC of claim 9, wherein the ML_SEQ interface further includes ML_SYNC_ACK signals, and once one of the cores has drained pending jobs upon receipt of the ML_FREEZE signals, said core asserts the ML_SYNC_ACK signals to indicate that said core has reached a quiescent state.
11. The self-optimizing SOC of claim 10, wherein the ML module further includes a ML_CFG_WR interface, and wherein once the ML module receives the ML_SYNC_ACK signals from all of the cores, accelerators, interconnect framework and memories, which indicates that the SOC has attained a quiescent state, the ML module generates a new set of configuration parameters using the ML_CFG_WR interface.
12. The self-optimizing SOC of claim 1, wherein the ML module further includes a ML module CFG_ACTION module containing new configuration parameters.
13. The self-optimizing SOC of claim 1, wherein the ML module further comprises a ML_RST interface that includes a ML_RST signal that is asserted by the ML module to the SOC reset controller to reset the SOC, in preparation for writing a new set of configuration parameters, where at least one parameter to be updated has a discontinuous change condition constraint, and in response, the SOC reset controller initiates a ML reset sequence to reset all of the cores, accelerators, interconnect framework, and memories and wherein the SoC reset controller initiates a ML boot sequence that uses the new configuration parameters instead of default configuration parameters.
14. A method of configuring a System on a chip (SOC) to perform at a predetermined performance level, wherein the SOC has multiple cores, multiple hardware accelerators, multiple memories and an interconnection framework therefor, the method comprising: setting a desired performance target for the SOC; executing a performance test on the SOC by a debug module of the SOC; measuring the performance of the SOC as determined by an iteration of the performance test against the desired performance target; enabling a Machine Learning (ML) module when the performance does not meet the desired performance target, wherein the ML module configures the SOC to meet the desired performance target by tuning configuration parameters of at least the cores, the accelerators, the interconnect framework and the memories by autonomously cycling through configuration training sequences until the desired performance target is achieved; classifying performance drops below a first predetermined performance threshold as pathological and saving the configuration parameters thereof to a pathological configuration list; classifying performance drops below a second predetermined performance threshold as deadlock and saving the configuration parameters thereof to a pathological configuration list; avoiding configuration settings that lead to performance drops below the first predetermined threshold by checking if new configuration parameters match one of the configuration settings stored in the pathological configuration list; and recovering from SOC configuration settings that lead to performance drops below the second predetermined threshold or deadlock like conditions by applying a SOC reset.
15. The method of claim 14, further comprising providing a protocol, by a machine learning (ML) module, for synchronized configuration parameter updates to avoid undefined behaviors due to dynamic runtime configuration changes, wherein the protocol includes the ML module receiving confirmation of quiescent state before pushing new configuration parameters.
16. The method of claim 15, wherein a reset timer causes a SOC reset controller to issue a reset if the quiescent state is not attained within a predetermined time.
17. The method of claim 15, wherein the reset comprises a ML reset in which a boot sequence of the SOC uses configuration parameters generated by the ML module instead of default configuration parameters.
18. The method of claim 14, further comprising: fetching data flow and communication flow information and the configuration parameters to define ML network parameters to build a ML network when dataflow is changed, and wherein the ML module uses the ML network to compute new SOC configuration parameters when the dataflow is changed and uses a saved, original ML network when the dataflow is not changed.
</claims>
</document>
